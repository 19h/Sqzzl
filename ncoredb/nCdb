<?php
        /*
         *      (c) The nCoreDB Algorithm. By Kenan Sulayman. All rights reserved.
         *      (c) The nCoreDB Implementation. By Kenan Sulayman. All rights reserved.
         */
        
        // Control-instance. A wrapper has been implemented, so it should be used.
        defined( "Interfaced" ) or die( "Wrapper is not registered." );
        defined( "wAuth" ) or die( "Wrapper is not used." );
        $g = get_included_files(  );
        if ( !in_array( wAuth, $g ) )
                exit( "Fault." );
        
        // there is no suffix.
        if ( strstr( $q = basename( __FILE__ ), "." ) || $q != "nCdb" )
                die( "This file must is named nCdb. No dots, no change of name." );
        
        // check integrity
        //if ( class_exists("nCdb") )
                //die( "Must not redeclare nCdb class." );
        
        // Crypto classes
        
        class nCdbh {
                public function encrypt( $text, $key ) {
                        list( $p, $r, $keysize ) = unserialize( base64_decode( $key ) );
                        $in = $this->blockify( $text, $keysize );
                        $out = '';
                        foreach ( $in as $block ) {
                                if ( $block ) {
                                        $cryptblock = $this->crypt_num( $this->txt2num( $block ), $p, $r );
                                        $out .= $this->long_base_convert( $cryptblock, 10, 145 ) . " ";
                                }
                        }
                        return $out;
                }
                
                public function decrypt( $code, $key ) {
                        list( $q, $r ) = unserialize( base64_decode( $key ) );
                        $in = explode( " ", $code );
                        $out = '';
                        foreach ( $in as $block ) {
                                if ( $block ) {
                                        $block = $this->long_base_convert( $block, 145, 10 );
                                        $out .= $this->num2txt( $this->crypt_num( $block, $q, $r ) );
                                }
                        }
                        return $out;
                }
                
                public function generate_keypair( $bits = 1024 ) {
                        $km = new nCdbk(  );
                        $keys = $km->make_keys( $bits );
                        $pub = base64_encode( serialize( array( $keys[ 0 ], $keys[ 2 ], $bits ) ) );
                        $priv = base64_encode( serialize( array( $keys[ 1 ], $keys[ 2 ], $bits ) ) );
                        return array( $pub, $priv );
                }
                
                public function crypt_num( $num, $key, $mod ) {
                        return $this->powmod( $num, $key, $mod );
                }
                
                public function long_base_convert( $numstring, $frombase, $tobase ) {
                        $chars = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-+=!@#$%^*(){[}]|:,.?/`~•¶§ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥ƒáíóúñÑªº¿¬¡«»¯ßµ±÷;<>";
                        $fromstring = substr( $chars, 0, $frombase );
                        $tostring = substr( $chars, 0, $tobase );
                        
                        $length = strlen( $numstring );
                        $result = '';
                        for ( $i = 0; $i < $length; ++$i ) {
                                $number[ $i ] = strpos( $fromstring, $numstring{$i} );
                        }
                        do {
                                $divide = 0;
                                $newlen = 0;
                                for ( $i = 0; $i < $length; ++$i ) {
                                        $divide = $divide * $frombase + $number[ $i ];
                                        if ( $divide >= $tobase ) {
                                                $number[ $newlen++ ] = ( int )( $divide / $tobase );
                                                $divide = $divide % $tobase;
                                        } elseif ( $newlen > 0 ) {
                                                $number[ $newlen++ ] = 0;
                                        }
                                }
                                $length = $newlen;
                                $result = $tostring{$divide} . $result;
                        } while ( $newlen != 0 );
                        return $result;
                }
                
                public function blockify( $in, $keysize ) {
                        $b_len = floor( $keysize / 8 );
                        return str_split( $in, $b_len );
                }
                
                public function txt2num( $str ) {
                        $result = '0';
                        $n = strlen( $str );
                        do {
                                $result = bcadd( bcmul( $result, '256' ), ord( $str{--$n} ) );
                        } while ( $n > 0 );
                        return $result;
                }
                
                public function num2txt( $num ) {
                        $result = '';
                        do {
                                $result .= chr( bcmod( $num, '256' ) );
                                $num = bcdiv( $num, '256' );
                        } while ( bccomp( $num, '0' ) );
                        return $result;
                }
                
                public function powmod( $num, $pow, $mod ) {
                        if ( function_exists( 'bcpowmod' ) ) {
                                return bcpowmod( $num, $pow, $mod );
                        }
                        
                        $result = '1';
                        do {
                                if ( !bccomp( bcmod( $pow, '2' ), '1' ) ) {
                                        $result = bcmod( bcmul( $result, $num ), $mod );
                                }
                                $num = bcmod( bcpow( $num, '2' ), $mod );
                                
                                $pow = bcdiv( $pow, '2' );
                        } while ( bccomp( $pow, '0' ) );
                        return $result;
                }
        }
        
        class nCdbk {
                static $primes = null;
                
                public function __construct(  ) {
                        if ( is_null( $this->primes ) ) {
                                for ( $i = 0; $i < 20000; ++$i ) {
                                        $numbers[  ] = $i;
                                }
                                
                                $numbers[ 0 ] = $numbers[ 1 ] = 0;
                                foreach ( $numbers as $i => $num ) {
                                        if ( !$num ) {
                                                continue;
                                        }
                                        $j = $i;
                                        
                                        for ( $j += $i; $j < 20000; $j += $i ) {
                                                $numbers[ $j ] = 0;
                                        }
                                }
                                foreach ( $numbers as $num ) {
                                        if ( $num ) {
                                                $this->primes[  ] = $num;
                                        }
                                }
                        }
                }
                
                public function make_keys( $bits = 1024, $u = false, $v = false ) {
                        $variant = rand( 0, 2 );
                        if ( !$u )
                                $u = $this->make_prime( ceil( $bits / 2 ) + $variant );
                        if ( !$v )
                                $v = $this->make_prime( floor( $bits / 2 ) - $variant );
                        while ( substr( $u, -16, 2 ) < ( substr( $v, -16, 2 ) + 2 ) && substr( $u, -16, 2 ) > ( substr( $v, -16, 2 ) - 2 ) ) {
                                $v = $pm->make_prime( intval( $digits / 2 ) );
                        }
                        
                        
                        $r = bcmul( $u, $v );
                        $phir = bcmul( bcsub( $u, 1 ), bcsub( $v, 1 ) );
                        
                        
                        $psize = ( $bits > 51 ) ? 17 : intval( $bits / 3 );
                        $p = $this->make_prime( $psize );
                        
                        
                        $q = $this->euclid( $p, $phir );
                        
                        return array( $p, $q, $r );
                }
                
                public function make_prime( $bits ) {
                        $min = bcpow( 2, $bits - 1 );
                        $max = bcsub( bcmul( $min, 2 ), 1 );
                        $digits = strlen( $max );
                        while ( strlen( $min ) < $digits )
                                $min = "0" . $min;
                        $ent = $this->entropyarray( $digits );
                        $maxed = true;
                        $mined = true;
                        $num = '';
                        for ( $i = 0; $i < $digits; ++$i ) {
                                $thismax = 9;
                                $thismin = 0;
                                if ( $maxed )
                                        $thismax = substr( $max, $i, 1 );
                                if ( $mined )
                                        $thismin = substr( $min, $i, 1 );
                                
                                
                                $thisdigit = ( $ent[ $i ] + rand( 0, 9 ) ) % 10;
                                if ( $i == $digits - 1 )
                                        while ( $thisdigit != 1 && $thisdigit != 3 && $thisdigit != 7 && $thisdigit != 9 && $thisdigit <= $thismax && $thisdigit >= $thismin )
                                                $thisdigit = ( $thisdigit + rand( 0, 9 ) ) % 10;
                                else
                                        while ( $thisdigit <= $thismax && $thisdigit >= $thismin )
                                                $thisdigit = ( $thisdigit + rand( 0, 9 ) ) % 10;
                                $num .= $thisdigit;
                                if ( $maxed && $thisdigit < $thismax )
                                        $maxed = false;
                                if ( $mined && $thisdigit > $thismin )
                                        $mined = false;
                        }
                        
                        
                        while ( !$this->is_prime( $num ) ) {
                                if ( substr( $num, -1, 1 ) == 3 )
                                        $num = bcadd( $num, 4 );
                                else
                                        $num = bcadd( $num, 2 );
                                $tries++;
                        }
                        return $num;
                }
                
                public function entropyarray( $digits ) {
                        $a = base_convert( md5( microtime(  ) ), 16, 10 );
                        $b = base_convert( sha1( @exec( 'uptime' ) ), 16, 10 );
                        $c = mt_rand(  );
                        $d = disk_total_space( "/" );
                        $e = rand(  );
                        $f = memory_get_usage(  );
                        
                        
                        $num = str_shuffle( preg_replace( "[^0-9]", '', $a . $b . $c . $d . $e ) );
                        if ( strlen( $num ) > $digits )
                                $num = substr( $num, 0, $digits );
                        else
                                while ( strlen( $num ) < $digits )
                                        $num = str_shuffle( substr( base_convert( md5( $num ), 16, 10 ), 3, 1 ) . $num );
                        
                        
                        $ent_array = str_split( $num );
                        return $ent_array;
                }
                
                public function is_prime( $num ) {
                        if ( bccomp( $num, 1 ) < 1 )
                                return false;
                        
                        foreach ( $this->primes as $prime ) {
                                if ( bccomp( $num, $prime ) == 0 )
                                        return true;
                                if ( !bcmod( $num, $prime ) )
                                        return false;
                        }
                        
                        
                        for ( $i = 0; $i < 7; ++$i ) {
                                if ( !$this->_millerTest( $num, $this->primes[ $i ] ) )
                                        return false;
                        }
                        
                        
                        return true;
                }
                
                public function _millerTest( $num, $base ) {
                        if ( !bccomp( $num, '1' ) ) {
                                return false;
                        }
                        $tmp = bcsub( $num, '1' );
                        
                        $zero_bits = 0;
                        while ( !bccomp( bcmod( $tmp, '2' ), '0' ) ) {
                                $zero_bits++;
                                $tmp = bcdiv( $tmp, '2' );
                        }
                        
                        $tmp = $this->powmod( $base, $tmp, $num );
                        if ( !bccomp( $tmp, '1' ) ) {
                                return true;
                        }
                        
                        while ( $zero_bits-- ) {
                                if ( !bccomp( bcadd( $tmp, '1' ), $num ) ) {
                                        return true;
                                }
                                $tmp = $this->powmod( $tmp, '2', $num );
                        }
                        
                        return false;
                }
                
                public function euclid( $num, $mod ) {
                        $x = '1';
                        $y = '0';
                        $num1 = $mod;
                        do {
                                $tmp = bcmod( $num, $num1 );
                                $q = bcdiv( $num, $num1 );
                                $num = $num1;
                                $num1 = $tmp;
                                
                                $tmp = bcsub( $x, bcmul( $y, $q ) );
                                $x = $y;
                                $y = $tmp;
                        } while ( bccomp( $num1, '0' ) );
                        if ( bccomp( $x, '0' ) < 0 ) {
                                $x = bcadd( $x, $mod );
                        }
                        return $x;
                }
                
                public function powmod( $num, $pow, $mod ) {
                        if ( function_exists( 'bcpowmod' ) ) {
                                return bcpowmod( $num, $pow, $mod );
                        }
                        
                        
                        $result = '1';
                        do {
                                if ( !bccomp( bcmod( $pow, '2' ), '1' ) ) {
                                        $result = bcmod( bcmul( $result, $num ), $mod );
                                }
                                $num = bcmod( bcpow( $num, '2' ), $mod );
                                
                                $pow = bcdiv( $pow, '2' );
                        } while ( bccomp( $pow, '0' ) );
                        return $result;
                }
        }
        
        $text = "Peter Piper picked a peck of pickled peppers";
        $RSA = new nCdbh();
        $keys = $RSA->generate_keypair(1024);
        $encrypted = $RSA->encrypt($text, $keys[0]);
        $decrypted = $RSA->decrypt($encrypted, $keys[1]);
        echo $decrypted; //Will print Peter Piper picked a peck of pickled peppers
        
        final class nCdb {
                public function __exists( $db ) {
                        if ( file_exists( $db ) )
                                if ( file_exists( $db . "/_v" ) )
                                        return true;
                                else
                                        return false;
                        else
                                return false;
                }
                
                public function __create( $db, $keys, $salt ) {
                }
        }
?>